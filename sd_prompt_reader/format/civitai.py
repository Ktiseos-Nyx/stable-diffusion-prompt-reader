# Civitai Mojibake Parsing
# sd_prompt_reader/format/civitai.py

import json
import re


import json
import re
from .base_format import BaseFormat # Assuming BaseFormat is in base_format.py in the same dir
                                   # or from ..format.base_format if base_format is one level up
                                   # Adjust based on actual file structure in their project
from ..logger import Logger # Relative import to get their logger from the parent directory

class CivitaiComfyUIFormat(BaseFormat):
    """
    Parser for UserComment metadata found in JPEGs generated by
    Civitai's ComfyUI-based service. This typically involves a
    "charset=Unicode" prefix followed by a mojibake UTF-16LE JSON string
    representing the ComfyUI workflow, which contains an "extraMetadata"
    key with A1111-style parameters.
    """
    def __init__(self, info: dict = None, raw: str = ""):
        super().__init__(info, raw)
        # Add any specific attributes this parser might need
        self.workflow_data: dict | None = None # To store the full decoded workflow

    def _decode_civitai_user_comment(self, uc_string: str) -> str | None:
        """
        Decodes the specific Civitai UserComment string.
        Handles "charset=Unicode" prefix and mojibake reversal.
        Returns a clean JSON string if successful, else None.
        """
        if not uc_string or not isinstance(uc_string, str):
            return None

        data_to_process = uc_string
        prefix_pattern = r'^charset\s*=\s*["\']?(UNICODE|UTF-16|UTF-16LE)["\']?\s*'
        match = re.match(prefix_pattern, uc_string, re.IGNORECASE)
        if match:
            data_to_process = uc_string[len(match.group(0)):].strip()

        # Only attempt mojibake reversal if specific characters are present
        # and it doesn't already look like clean JSON.
        if ('笀' in data_to_process or '∀' in data_to_process or 'izarea' in data_to_process) and \
           not (data_to_process.startswith('{') and data_to_process.endswith('}')):
            try:
                byte_list = []
                for char_from_mojibake in data_to_process:
                    codepoint_val = ord(char_from_mojibake)
                    byte_list.append((codepoint_val >> 8) & 0xFF)
                    byte_list.append(codepoint_val & 0xFF)
                
                recovered_bytes = bytes(byte_list)
                json_string = recovered_bytes.decode('utf-16le', errors='strict')
                json.loads(json_string) # Validate
                return json_string
            except Exception:
                return None # Mojibake reversal failed
        
        # If no mojibake, check if it's already plain JSON
        if data_to_process.startswith('{') and data_to_process.endswith('}'):
            try:
                json.loads(data_to_process) # Validate
                return data_to_process
            except json.JSONDecodeError:
                return None # Looked like JSON but wasn't valid
        
        return None # Not the expected Civitai JSON format

    def parse(self):
        # The raw UserComment string is expected in self._raw
        if not self._raw:
            self.status = BaseFormat.Status.UNREAD # Or FORMAT_ERROR
            return self.status

        cleaned_workflow_json_str = self._decode_civitai_user_comment(self._raw)

        if not cleaned_workflow_json_str:
            self.status = BaseFormat.Status.FORMAT_ERROR
            self._error = "Failed to decode Civitai UserComment or not a Civitai JSON format."
            return self.status

        try:
            self.workflow_data = json.loads(cleaned_workflow_json_str)
        except json.JSONDecodeError as e:
            self.status = BaseFormat.Status.FORMAT_ERROR
            self._error = f"Decoded UserComment is not valid JSON: {e}"
            return self.status

        # Extract A1111-style parameters from "extraMetadata"
        extra_metadata_str = self.workflow_data.get("extraMetadata")
        if extra_metadata_str and isinstance(extra_metadata_str, str):
            try:
                extra_meta_dict = json.loads(extra_metadata_str)
                
                self._positive = extra_meta_dict.get("prompt", "")
                self._negative = extra_meta_dict.get("negativePrompt", "")
                
                # Populate self._parameter dictionary
                # BaseFormat._parameter is used by sd-prompt-reader to store these
                # Note: sd-prompt-reader A1111 parser normalizes keys (e.g., "CFG scale" -> "cfg_scale")
                # You might want to do similar normalization or decide on consistent keys.
                
                # Example direct population (keys might need normalization for consistency with other parsers)
                if "steps" in extra_meta_dict: self._parameter["steps"] = str(extra_meta_dict["steps"])
                if "CFG scale" in extra_meta_dict: self._parameter["cfg_scale"] = str(extra_meta_dict["CFG scale"])
                elif "cfgScale" in extra_meta_dict: self._parameter["cfg_scale"] = str(extra_meta_dict["cfgScale"])
                if "sampler" in extra_meta_dict: self._parameter["sampler_name"] = str(extra_meta_dict["sampler"])
                elif "sampler_name" in extra_meta_dict: self._parameter["sampler_name"] = str(extra_meta_dict["sampler_name"])
                if "seed" in extra_meta_dict: self._parameter["seed"] = str(extra_meta_dict["seed"])
                
                # Width and Height might be in extraMetadata or from the main workflow's image nodes.
                # For simplicity, let's assume they might be in extraMetadata for now.
                # BaseFormat expects self._width and self._height to be set.
                self._width = str(extra_meta_dict.get("width", 0))
                self._height = str(extra_meta_dict.get("height", 0))

                # The "setting" string in BaseFormat is usually the raw A1111 settings line.
                # You could try to reconstruct it from extra_meta_dict if needed, or leave it.
                # For example:
                # settings_parts = []
                # if "steps" in self._parameter: settings_parts.append(f"Steps: {self._parameter['steps']}")
                # ... etc. ...
                # self._setting = ", ".join(settings_parts)
                # Or, more simply, just store the extra_meta_dict as a string if that's useful
                self._raw_setting = extra_metadata_str # Store the raw extraMetadata string

                self.status = BaseFormat.Status.READ_SUCCESS
                
            except json.JSONDecodeError as e_extra:
                self.status = BaseFormat.Status.FORMAT_ERROR
                self._error = f"Failed to parse JSON from 'extraMetadata': {e_extra}"
                # Still return what we could get from the main workflow if desired, or just error out.
                # If we error here, the user won't see the main workflow even if it was valid.
                # A design choice: is partial data okay?
        else:
            # No extraMetadata, but we have the ComfyUI workflow.
            # This could be parsed by their existing ComfyUI parser, or you add basic extraction here.
            # For now, let's say this specific Civitai parser *expects* extraMetadata.
            # If it's just a plain ComfyUI workflow without extraMetadata, their ComfyUI parser should handle it.
            self.status = BaseFormat.Status.FORMAT_ERROR 
            self._error = "Civitai UserComment workflow decoded, but 'extraMetadata' key was missing or not a string."
            # To be more robust, you could try parsing the main workflow here using ComfyUI logic if extraMetadata is absent.

        # Store the full decoded workflow in self.raw (as BaseFormat does) or a custom attribute
        self.raw = cleaned_workflow_json_str # Overwrites self._raw from init if needed by BaseFormat consumers

        return self.status
