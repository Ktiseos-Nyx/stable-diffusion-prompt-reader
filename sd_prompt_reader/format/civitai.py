# Civitai Mojibake Parsing
# sd_prompt_reader/format/civitai.py

# sd_prompt_reader/format/civitai.py (Conceptual file for your fork)

import json
import re
# Ensure these imports are correct based on the file structure in stable-diffusion-prompt-reader
from .base_format import BaseFormat 
from ..logger import Logger # Assumes logger.py is in the parent directory (sd_prompt_reader/)

class CivitaiComfyUIFormat(BaseFormat):
    """
    Parser for UserComment metadata found in JPEGs generated by
    Civitai's ComfyUI-based service. This typically involves a
    "charset=Unicode" prefix followed by a mojibake UTF-16LE JSON string
    representing the ComfyUI workflow, which contains an "extraMetadata"
    key with A1111-style parameters.
    """
    def __init__(self, info: dict = None, raw: str = ""):
        super().__init__(info, raw)
        # --- LOGGER INITIALIZATION ---
        # Create a named logger for this specific parser.
        # The name helps in filtering logs if needed.
        self._logger = Logger(f"{self.__class__.__module__}.{self.__class__.__name__}")
        # --- END LOGGER INITIALIZATION ---
        
        self.workflow_data: dict | None = None 
        # self._error is already an attribute in BaseFormat, so super().__init__() handles it.

    def _decode_civitai_user_comment(self, uc_string: str) -> str | None:
        """
        Decodes the specific Civitai UserComment string.
        Handles "charset=Unicode" prefix and mojibake reversal.
        Returns a clean JSON string if successful, else None.
        """
        self._logger.debug(f"Attempting to decode UserComment string (first 50): {uc_string[:50]}")
        if not uc_string or not isinstance(uc_string, str):
            self._logger.warn("UserComment string is empty or not a string.")
            return None

        data_to_process = uc_string
        prefix_pattern = r'^charset\s*=\s*["\']?(UNICODE|UTF-16|UTF-16LE)["\']?\s*'
        match = re.match(prefix_pattern, uc_string, re.IGNORECASE)
        if match:
            data_to_process = uc_string[len(match.group(0)):].strip()
            self._logger.debug(f"Stripped 'charset=Unicode' prefix. Remaining: {data_to_process[:50]}")

        if ('笀' in data_to_process or '∀' in data_to_process or 'izarea' in data_to_process) and \
           not (data_to_process.startswith('{') and data_to_process.endswith('}')):
            self._logger.debug("Mojibake characters detected. Attempting reversal.")
            try:
                byte_list = []
                for char_from_mojibake in data_to_process:
                    codepoint_val = ord(char_from_mojibake)
                    byte_list.append((codepoint_val >> 8) & 0xFF)
                    byte_list.append(codepoint_val & 0xFF)
                
                recovered_bytes = bytes(byte_list)
                json_string = recovered_bytes.decode('utf-16le', errors='strict')
                json.loads(json_string) # Validate
                self._logger.debug("Mojibake reversal successful.")
                return json_string
            except Exception as e:
                self._logger.warn(f"Mojibake reversal failed: {e}")
                return None 
        
        if data_to_process.startswith('{') and data_to_process.endswith('}'):
            self._logger.debug("Data looks like plain JSON. Validating.")
            try:
                json.loads(data_to_process) 
                self._logger.debug("Plain JSON validation successful.")
                return data_to_process
            except json.JSONDecodeError as e:
                self._logger.warn(f"Plain JSON validation failed: {e}")
                return None
        
        self._logger.debug("UserComment string not recognized as Civitai JSON (mojibake or plain).")
        return None

    def parse(self):
        self._logger.info(f"Attempting to parse using {self.__class__.__name__}.")
        if not self._raw:
            self._logger.warn("Raw data (UserComment) is empty. Cannot parse.")
            self.status = BaseFormat.Status.FORMAT_ERROR 
            self._error = "Raw UserComment data is empty."
            return self.status

        cleaned_workflow_json_str = self._decode_civitai_user_comment(self._raw)

        if not cleaned_workflow_json_str:
            self._logger.warn("Failed to decode UserComment or not a Civitai JSON format.")
            self.status = BaseFormat.Status.FORMAT_ERROR
            self._error = "UserComment decoding failed or not the expected Civitai JSON structure."
            return self.status

        try:
            self.workflow_data = json.loads(cleaned_workflow_json_str)
            self._logger.info("Successfully parsed main workflow JSON from UserComment.")
        except json.JSONDecodeError as e:
            self._logger.error(f"Decoded UserComment is not valid JSON: {e}")
            self.status = BaseFormat.Status.FORMAT_ERROR
            self._error = f"Invalid JSON in decoded UserComment: {e}"
            return self.status

        extra_metadata_str = self.workflow_data.get("extraMetadata")
        if extra_metadata_str and isinstance(extra_metadata_str, str):
            self._logger.info("Found 'extraMetadata' string. Attempting to parse.")
            try:
                extra_meta_dict = json.loads(extra_metadata_str)
                self._logger.debug("'extraMetadata' parsed into dict successfully.")
                
                self._positive = extra_meta_dict.get("prompt", "")
                self._negative = extra_meta_dict.get("negativePrompt", "")
                
                self._parameter = {} # Ensure it's initialized
                if "steps" in extra_meta_dict: self._parameter["steps"] = str(extra_meta_dict["steps"])
                
                # Handle CFG Scale key variations
                if "CFG scale" in extra_meta_dict: self._parameter["cfg_scale"] = str(extra_meta_dict["CFG scale"])
                elif "cfgScale" in extra_meta_dict: self._parameter["cfg_scale"] = str(extra_meta_dict["cfgScale"])
                
                # Handle Sampler key variations
                if "sampler" in extra_meta_dict: self._parameter["sampler_name"] = str(extra_meta_dict["sampler"])
                elif "sampler_name" in extra_meta_dict: self._parameter["sampler_name"] = str(extra_meta_dict["sampler_name"])
                
                if "seed" in extra_meta_dict: self._parameter["seed"] = str(extra_meta_dict["seed"])
                
                # BaseFormat expects _width and _height attributes (usually as int, but string here for consistency with _parameter)
                self._width = str(extra_meta_dict.get("width", 0))
                self._height = str(extra_meta_dict.get("height", 0))

                # The "setting" string in BaseFormat is usually the raw A1111 settings line.
                # Here, we can store the extra_metadata_str as the raw settings part.
                self._raw_setting = extra_metadata_str 
                # Alternatively, reconstruct a settings string:
                # settings_parts = [f"{k}: {v}" for k, v in self._parameter.items()]
                # self._setting = ", ".join(settings_parts) # This would be more like A1111 _setting

                self._logger.info("Successfully extracted parameters from 'extraMetadata'.")
                self.status = BaseFormat.Status.READ_SUCCESS
                
            except json.JSONDecodeError as e_extra:
                self._logger.error(f"Failed to parse JSON from 'extraMetadata': {e_extra}")
                self.status = BaseFormat.Status.FORMAT_ERROR
                self._error = f"Invalid JSON in 'extraMetadata': {e_extra}"
        else:
            self._logger.warn("'extraMetadata' not found or not a string in UserComment workflow.")
            # If extraMetadata is considered essential for this parser to be a "success"
            self.status = BaseFormat.Status.FORMAT_ERROR 
            self._error = "'extraMetadata' missing or invalid in Civitai UserComment."
            # If parsing the main workflow is still useful without extraMetadata,
            # you might set status to READ_SUCCESS but log a warning.
            # For a dedicated Civitai parser, extraMetadata is likely key.

        # Store the full decoded workflow in self.raw
        # BaseFormat's self.raw is usually the primary data string the parser worked on.
        # Here, cleaned_workflow_json_str is the most "raw" complete data we have successfully processed.
        self.raw = cleaned_workflow_json_str 

        return self.status
