# sd_prompt_reader/format/civitai.py


import json
import re
# Ensure these imports are correct based on the file structure in stable-diffusion-prompt-reader
from .base_format import BaseFormat 
from ..logger import Logger # Assumes logger.py is in the parent directory (sd_prompt_reader/)

class CivitaiComfyUIFormat(BaseFormat):
    """
    Parser for UserComment metadata found in JPEGs generated by
    Civitai's ComfyUI-based service. This typically involves a
    "charset=Unicode" prefix and potentially a mojibake UTF-16LE JSON string
    representing the ComfyUI workflow, which contains an "extraMetadata"
    key with A1111-style parameters.
    
    This parser expects the raw UserComment string as decoded by piexif,
    which might be clean JSON or still contain the "charset=Unicode" prefix
    and/or mojibake if piexif didn't fully clean it.
    """
    def __init__(self, info: dict = None, raw: str = ""):
        super().__init__(info, raw)
        # Create a named logger for this specific parser.
        self._logger = Logger(f"SDPR.{self.__class__.__name__}") # Shorter name for logs
        self.workflow_data: dict | None = None 
        # self._error and self._status are initialized in BaseFormat

    def _decode_civitai_user_comment(self, uc_string: str) -> str | None:
        """
        Decodes/cleans the UserComment string, expecting piexif's output.
        Handles "charset=Unicode" prefix and potential mojibake reversal.
        Returns a clean JSON string if successful, else None.
        """
        self._logger.debug(f"Attempting to decode UserComment string (first 70): '{uc_string[:70]}'")
        if not uc_string or not isinstance(uc_string, str):
            self._logger.warn("UserComment string is empty or not a string.")
            return None

        data_to_process = uc_string
        prefix_pattern = r'^charset\s*=\s*["\']?(UNICODE|UTF-16|UTF-16LE)["\']?\s*'
        match = re.match(prefix_pattern, uc_string, re.IGNORECASE)
        if match:
            data_to_process = uc_string[len(match.group(0)):].strip()
            self._logger.debug(f"Stripped 'charset=Unicode' prefix. Remaining: '{data_to_process[:50]}'")

        # Check for mojibake ONLY if piexif's output might still contain it.
        # If piexif provides clean JSON, this block will likely be skipped.
        if ('笀' in data_to_process or '∀' in data_to_process or 'izarea' in data_to_process) and \
           not (data_to_process.startswith('{') and data_to_process.endswith('}')):
            self._logger.debug("Mojibake characters detected in string from piexif. Attempting reversal.")
            try:
                byte_list = []
                for char_from_mojibake in data_to_process:
                    codepoint_val = ord(char_from_mojibake)
                    byte_list.append((codepoint_val >> 8) & 0xFF)
                    byte_list.append(codepoint_val & 0xFF)
                
                recovered_bytes = bytes(byte_list)
                json_string = recovered_bytes.decode('utf-16le', errors='strict')
                json.loads(json_string) # Validate
                self._logger.debug("Mojibake reversal successful.")
                return json_string
            except Exception as e:
                self._logger.warn(f"Mojibake reversal failed: {e}")
                return None # Mojibake reversal failed, likely not the format we expect
        
        # If no mojibake (or reversal failed), check if it's already plain JSON
        if data_to_process.startswith('{') and data_to_process.endswith('}'):
            self._logger.debug("Data (post-prefix/post-mojibake-attempt) looks like plain JSON. Validating.")
            try:
                json.loads(data_to_process) 
                self._logger.debug("Plain JSON validation successful.")
                return data_to_process
            except json.JSONDecodeError as e:
                self._logger.warn(f"Plain JSON validation failed: {e}")
                return None
        
        self._logger.debug("UserComment string not recognized as Civitai JSON (mojibake or plain) after processing.")
        return None

    def parse(self):
        self._logger.info(f"Attempting to parse using {self.__class__.__name__}.")
        if not self._raw: # self._raw is the UserComment string from ImageDataReader (via piexif)
            self._logger.warn("Raw data (UserComment) is empty. Cannot parse.")
            self._status = BaseFormat.Status.FORMAT_ERROR # CORRECTED
            self._error = "Raw UserComment data is empty."
            return self._status # CORRECTED

        cleaned_workflow_json_str = self._decode_civitai_user_comment(self._raw)

        if not cleaned_workflow_json_str:
            self._logger.warn("Failed to decode UserComment or not a Civitai JSON format.")
            self._status = BaseFormat.Status.FORMAT_ERROR # CORRECTED
            self._error = "UserComment decoding failed or not the expected Civitai JSON structure."
            return self._status # CORRECTED

        try:
            self.workflow_data = json.loads(cleaned_workflow_json_str)
            self._logger.info("Successfully parsed main workflow JSON from UserComment.")
        except json.JSONDecodeError as e:
            self._logger.error(f"Decoded UserComment is not valid JSON: {e}")
            self._status = BaseFormat.Status.FORMAT_ERROR # CORRECTED
            self._error = f"Invalid JSON in decoded UserComment: {e}"
            return self._status # CORRECTED

        extra_metadata_str = self.workflow_data.get("extraMetadata")
        if extra_metadata_str and isinstance(extra_metadata_str, str):
            self._logger.info("Found 'extraMetadata' string. Attempting to parse.")
            try:
                extra_meta_dict = json.loads(extra_metadata_str)
                self._logger.debug("'extraMetadata' parsed into dict successfully.")
                
                self._positive = extra_meta_dict.get("prompt", "")
                self._negative = extra_meta_dict.get("negativePrompt", "")
                
                self._parameter = {} # Ensure it's initialized
                if "steps" in extra_meta_dict: self._parameter["steps"] = str(extra_meta_dict["steps"])
                
                if "CFG scale" in extra_meta_dict: self._parameter["cfg_scale"] = str(extra_meta_dict["CFG scale"])
                elif "cfgScale" in extra_meta_dict: self._parameter["cfg_scale"] = str(extra_meta_dict["cfgScale"])
                
                if "sampler" in extra_meta_dict: self._parameter["sampler_name"] = str(extra_meta_dict["sampler"])
                elif "sampler_name" in extra_meta_dict: self._parameter["sampler_name"] = str(extra_meta_dict["sampler_name"])
                
                if "seed" in extra_meta_dict: self._parameter["seed"] = str(extra_meta_dict["seed"])
                
                # These are expected by BaseFormat properties, often as int, but string for _parameter consistency
                self._width = str(extra_meta_dict.get("width", getattr(self, "_width", 0))) # Use initial if not in extra
                self._height = str(extra_meta_dict.get("height", getattr(self, "_height", 0))) # Use initial if not in extra

                # Store the raw extraMetadata string as the settings string for now
                self._raw_setting = extra_metadata_str 
                # self._setting could be a reconstructed A1111-style string if needed by their tooling
                
                # Optional: Populate self.tool if this parser wants to set a more specific name
                # self.tool = "Civitai ComfyUI Workflow" 

                self._logger.info("Successfully extracted parameters from 'extraMetadata'.")
                self._status = BaseFormat.Status.READ_SUCCESS # CORRECTED
                
            except json.JSONDecodeError as e_extra:
                self._logger.error(f"Failed to parse JSON from 'extraMetadata': {e_extra}")
                self._status = BaseFormat.Status.FORMAT_ERROR # CORRECTED
                self._error = f"Invalid JSON in 'extraMetadata': {e_extra}"
                # Do not return yet, self.raw is still useful below
        else:
            self._logger.warn("'extraMetadata' not found or not a string in UserComment workflow.")
            # If extraMetadata is considered essential for THIS parser, mark as format error.
            # If the main workflow itself is useful data, could be partial success.
            self._status = BaseFormat.Status.FORMAT_ERROR # CORRECTED
            self._error = "'extraMetadata' missing or invalid in Civitai UserComment."

        # Store the full decoded workflow in self.raw for access by ImageDataReader.raw property
        self.raw = cleaned_workflow_json_str 

        return self._status # CORRECTED (always return the final status)
